<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Detailed Machine Learning Hierarchy Flow</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* General Dark Theme Setup */
        body {
            background-color: #111827; /* Dark Gray / Black */
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            /* REMOVED: overflow: hidden; -> Now allows scrolling */
        }

        /* SVG Container - Removed 100vh height to allow it to grow */
        .chart-container {
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align chart to the top */
            width: 100%;
            min-height: 300vh; /* Ensures minimum screen size */
        }

        /* D3 Link Style (The connecting lines) */
        .link {
            fill: none;
            stroke-width: 2px;
            stroke: #6B7280; 
            /* Added for smooth, rounded corners */
            stroke-linecap: round; 
            stroke-linejoin: round;
        }

        /* D3 Node Text Style */
        .node text {
            fill: #E5E7EB; /* Light text color */
            font-size: 14px;
            font-weight: 500;
        }
    </style>
</head>
<body>

    <div class="chart-container" id="chart-container">
        <!-- D3 SVG will be appended here -->
    </div>

    <script>
        // Use a self-invoking function to encapsulate the D3 logic
        (function() {
            // Updated Data structure based on the new, detailed hierarchy
            const data = {
                "name": "Machine Learning",
                "children": [
                    {
                        "name": "Supervised Learning",
                        "children": [
                            {
                                "name": "Standard Algorithms",
                                "children": [
                                    {
                                        "name": "Classification",
                                        "children": [
                                            {"name": "Logistic Regression"},
                                            {"name": "K-Nearest Neighbors (KNN)"},
                                            {"name": "Naive Bayes"},
                                            {"name": "Decision Tree Classifier"},
                                            {"name": "Support Vector Machine (SVM)"},
                                            {"name": "Linear Discriminant Analysis (LDA)"},
                                            {"name": "Quadratic Discriminant Analysis (QDA)"}
                                        ]
                                    },
                                    {
                                        "name": "Regression",
                                        "children": [
                                            {"name": "Linear Regression"},
                                            {"name": "Ridge / Lasso / ElasticNet"},
                                            {"name": "Polynomial Regression"},
                                            {"name": "Decision Tree Regressor"},
                                            {"name": "KNN Regressor"},
                                            {"name": "Support Vector Regressor (SVR)"}
                                        ]
                                    }
                                ]
                            },
                            {
                                "name": "Advanced Algorithms (Ensemble / Meta-Models)",
                                "children": [
                                    {
                                        "name": "Bagging",
                                        "children": [
                                            {"name": "BaggingClassifier / BaggingRegressor"},
                                            {"name": "Random Forest"},
                                            {"name": "Extra Trees"}
                                        ]
                                    },
                                    {
                                        "name": "Boosting",
                                        "children": [
                                            {"name": "AdaBoost"},
                                            {"name": "Gradient Boosting Machines (GBM)"},
                                            {"name": "XGBoost"},
                                            {"name": "LightGBM"},
                                            {"name": "CatBoost"}
                                        ]
                                    },
                                    {
                                        "name": "Stacking",
                                        "children": [
                                            {"name": "StackingClassifier"},
                                            {"name": "StackingRegressor"}
                                        ]
                                    },
                                    {
                                        "name": "Voting / Blending",
                                        "children": [
                                            {"name": "VotingClassifier"},
                                            {"name": "Averaging Regressor"}
                                        ]
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Unsupervised Learning",
                        "children": [
                            {
                                "name": "Clustering",
                                "children": [
                                    {"name": "K-Means"},
                                    {"name": "Hierarchical Clustering"},
                                    {"name": "DBSCAN / HDBSCAN"},
                                    {"name": "Mean Shift"},
                                    {"name": "Gaussian Mixture Models (GMM)"},
                                    {"name": "Spectral Clustering"}
                                ]
                            },
                            {
                                "name": "Dimensionality Reduction",
                                "children": [
                                    {"name": "PCA"},
                                    {"name": "Kernel PCA"},
                                    {"name": "t-SNE"},
                                    {"name": "UMAP"},
                                    {"name": "Autoencoders"}
                                ]
                            },
                            {
                                "name": "Association Rule Learning",
                                "children": [
                                    {"name": "Apriori"},
                                    {"name": "FP-Growth"},
                                    {"name": "Eclat"}
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Reinforcement Learning",
                        "children": [
                            {"name": "Q-Learning"},
                            {"name": "SARSA"},
                            {"name": "Deep Q-Networks (DQN)"},
                            {"name": "Policy Gradient Methods"},
                            {"name": "Actorâ€“Critic (A2C, A3C)"},
                            {"name": "PPO"},
                            {"name": "DDPG"},
                            {"name": "SAC"}
                        ]
                    }
                ]
            };

            // Define dynamic colors based on depth (hierarchy level)
            const depthColors = {
                0: "#DAD2D8", // Light Grey for root (Depth 0)
                1: "#51E5FF", // Cyan for level 1: Supervised, Unsupervised, RL
                2: "#EC9A29", // Gold/Orange for level 2: Standard, Advanced, Clustering, DR, Assoc.
                3: "#0EA5E9", // Sky Blue for level 3: Classification, Regression, Bagging, Boosting, etc.
                4: "#EC4899", // Pink for level 4 (most leaf nodes)
                5: "#FBBF24"  // Amber/Yellow for depth 5 (to ensure distinct color for max depth)
            };

            const container = d3.select("#chart-container");
            // Increased margin.top to 120 for more padding above the root node
            const margin = { top: 2000, right: 100, bottom: 50, left: 30 };
            
            let width;

            const svg = container.append("svg")
                .attr("class", "w-full"); // Removed height attribute here
                
            const g = svg.append("g");
            
            const tree = d3.tree();

            // Function to recalculate dimensions and update the chart
            function drawChart() {
                // Get container width
                width = document.getElementById('chart-container').clientWidth;
                
                const innerWidth = width - margin.left - margin.right;

                // Update G element dimensions/transforms
                g.attr("transform", `translate(${margin.left}, ${margin.top})`);
                
                // --- CRITICAL CHANGE: Use nodeSize instead of tree.size ---
                // [Vertical spacing (x-axis in horizontal layout), Horizontal spacing (y-axis)]
                // We set a fixed vertical spacing of 50px between nodes
                tree.nodeSize([50, 250]); 

                // 1. Convert the data to a hierarchy
                const root = d3.hierarchy(data);

                // 2. Compute the positions of the nodes
                const treeData = tree(root);

                // 3. --- CRITICAL CHANGE: Calculate Required Height ---
                // Find the lowest point (largest 'x' value) and add margins/padding
                const max_x = d3.max(treeData.descendants(), d => d.x);
                // Calculate height: max x position + top/bottom margins + extra padding (100)
                const requiredHeight = max_x + margin.top + margin.bottom + 100; 

                // Set the SVG height based on the calculation to force vertical scroll
                svg.attr("height", requiredHeight);

                // 4. Create Gradient Definitions in SVG <defs>
                svg.select("defs").remove();
                const defs = svg.append("defs");
                
                const nodesByDepth = Array.from(d3.group(treeData.descendants(), d => d.depth));
                
                nodesByDepth.forEach(([depth]) => {
                    const color = depthColors[depth] || depthColors[4]; 
                    const id = `node-gradient-${depth}`;

                    const linearGradient = defs.append("linearGradient")
                        .attr("id", id)
                        .attr("x1", "0%")
                        .attr("y1", "0%")
                        .attr("x2", "100%")
                        .attr("y2", "0%");

                    // Light Color Stop (Left side) - Uses hierarchy color
                    linearGradient.append("stop")
                        .attr("offset", "0%")
                        .attr("stop-color", color)
                        .attr("stop-opacity", 1);
                    
                    // Dark Color Stop (Right side - fading into background color)
                    linearGradient.append("stop")
                        .attr("offset", "100%")
                        .attr("stop-color", "#111827") 
                        .attr("stop-opacity", 1);
                });

                // 5. Select/Join Nodes (Enter/Update/Exit)
                const nodes = g.selectAll(".node")
                    .data(treeData.descendants(), d => d.id);

                // ENTER selection
                const nodeEnter = nodes.enter().append("g")
                    .attr("class", "node");

                // Add text to entering nodes
                nodeEnter.append("text")
                    .attr("dy", ".35em")
                    .attr("x", 10) // Offset text a little from the left edge
                    .attr("text-anchor", "start")
                    .text(d => d.data.name);

                // Add the rectangular background and border to entering nodes
                nodeEnter.insert("rect", "text") 
                    .attr("rx", 6)
                    .attr("ry", 6)
                    .attr("fill", "#1F2937") // Slightly lighter dark background for the box
                    .attr("stroke-width", 2);

                // MERGE selection (all nodes: entering + existing)
                const node = nodes.merge(nodeEnter);

                // 6. Measure Text Widths on all nodes
                const textWidths = [];
                node.selectAll("text").each(function(d) {
                    textWidths.push({
                        id: d.id, 
                        width: this.getComputedTextLength()
                    });
                });
                const measuredWidths = new Map(textWidths.map(i => [i.id, i.width]));

                // CONSTANTS needed for both node and link sizing
                const PADDING = 50; 
                const RECT_Y_OFFSET = -15; // Box height / 2
                const RECT_X_START = -(PADDING/2 - 10); // -15 (Left edge offset for text alignment)

                // 7. Update Rect and Position on all nodes (sizing the boxes)
                node.select("rect")
                    .attr("width", d => measuredWidths.get(d.id) + PADDING)
                    .attr("height", 30)
                    .attr("x", RECT_X_START) // Use the constant
                    .attr("y", RECT_Y_OFFSET) // Use the constant
                    // Apply dynamic gradient border
                    .attr("stroke", d => `url(#node-gradient-${d.depth})`); 

                // Update position for all nodes
                node.transition()
                    .duration(500)
                    .attr("transform", d => `translate(${d.y}, ${d.x})`);
                
                // EXIT selection
                nodes.exit().remove();
                
                // 8. Draw and Update Links (Placed behind nodes using insert)
                const links = g.selectAll(".link")
                    .data(treeData.links(), d => d.target.id);
                
                // EXIT
                links.exit().remove();

                // ENTER (Insert new links BEFORE the node groups to place them underneath)
                const linkEnter = links.enter().insert("path", ".node") 
                    .attr("class", "link");

                // MERGE
                const linkJoin = links.merge(linkEnter);
                
                // Update path definition on the merged selection
                linkJoin.transition()
                    .duration(500)
                    .attr("d", d => {
                        const source = d.source;
                        const target = d.target;
                        
                        // Calculate Source X: Right edge of the source node's box
                        const sourceTextWidth = measuredWidths.get(source.id) || 0;
                        const sourceRectWidth = sourceTextWidth + PADDING;
                        
                        // Right Edge = source.y + RECT_X_START + sourceRectWidth
                        const sourceX = source.y + RECT_X_START + sourceRectWidth;

                        // Calculate Target X: Left edge of the target node's box
                        // Left Edge = Target.y + RECT_X_START
                        const targetX = target.y + RECT_X_START;

                        // Define the horizontal midpoint for the elbow bend.
                        const midX = sourceX + (targetX - sourceX) / 2;

                        // Use a Cubic Bezier curve (C) to force a smooth 90-degree elbow.
                        return `M${sourceX},${source.x}
                                C${midX},${source.x}
                                 ${midX},${target.x}
                                 ${targetX},${target.x}`;
                    });
            }

            // Initial draw and setup resize listener
            drawChart();
            // We still need to redraw on resize to adjust horizontal width
            window.addEventListener('resize', drawChart);

        })();
    </script>
</body>
</html>
